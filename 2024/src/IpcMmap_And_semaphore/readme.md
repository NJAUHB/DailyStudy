#  mmap
mmap 其实也是一种**ipc进程间通信**的方式  
mmap在```<sys/mman.h>```头文件里面。有两个系统调用接口
```
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); // 创建。即我们要创建内存映射的一块区域，拿到这块区域之后，本来是在文件上的一块区域我们可以把它当作内存来操作，这样我们就可以通过指针去对这个地址做一些修改。

1. addr指定映射的虚拟内存地址（代表分配内存的起始地址），可以设置为 NULL，让 Linux 内核自动选择合适的虚拟内存地址。
2. length映射的长度，及区域大小。
3. prot：映射内存的保护模式，内存段可被执行、内存段可被读取、内存段可被写入、内存段不可访问。  
4. flags：指定映射的类型。
5. fd进行映射的文件句柄。（fd可置为-1，表示不从文件上进行映射。）
6. offset文件偏移量（从文件的何处开始映射）

示例：
int fd = open(filepath, O_RDWR, 0644);                           // 打开文件
void *p = mmap(NULL, 8192, PROT_WRITE, MAP_SHARED, fd, 4096); // 对文件进行映射

p 代表这块映射内存的首地址
```
mmap的优点：  
- 我们如果直接对一个文件（如test.txt）进行操作，需要通过IO读写，但是通过内存映射技术我们能够跨过了页缓存，减少了数据拷贝的次数，用内存操作取代了IO读写，减少了read、write的系统调用，提高了文件读写的效率。（参考：mmap2.cc）
- 提供了进程间共享内存及相互通信的方式。思考：如何通过mmap实现ipc通信。我们可以将一个文件映射到这块区域，让后两个进程都去操作映射的这块区域，就能够进行一个通信。
- 各进程修改操作可以直接反映在映射的区域内，从而被对方空间及时捕捉。

```
int munmap(void addr[.length], size_t length); // 卸载。
```
---
