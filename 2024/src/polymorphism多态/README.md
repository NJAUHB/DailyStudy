# 多态  
## 工厂类  
### 知识点   
1.  类中有纯虚函数`virtual fun(){}=0`则被称为是“抽象类”。抽象类不能使用new出对象（不能获取到单例），只有实现了这个纯虚函数的子类才能new出对象。  
2.  类中的虚函数主要作用是“运行时多态”，父类中提供虚函数的实现，为子类提供默认的函数实现。子类可以重写父类的虚函数实现子类的特殊化。  
3.  父类虚函数要不要实现？参考Many1.cpp  
    a. 在main函数中，如果有父类或者子类的实例对象，就**需要有父类的虚函数的实现**  
    b. 在main函数中，如果没有父类或者子类的实例对象，可以不实现父类的虚函数  
    c. 若把没有父类虚函数实现的代码编译生成一个so，其它代码编译链接这个so的时候可能会**出现链接错误！**  
    d. 如果把虚函数写成纯虚函数，也就不需要实现了，也就不会发生上述讨论  
### 实战   
参考代码Many2.cpp

# 继承
## 基本
公有继承(public)、私有继承(private)、保护继承(protected)是常用的三种继承方式。

1. 公有继承(public)

公有继承的特点是基类的公有成员和保护成员作为派生类的成员时，它们都保持原有的状态，而基类的私有成员仍然是私有的，不能被这个派生类的子类所访问。

2. 私有继承(private)

私有继承的特点是基类的公有成员和保护成员都作为派生类的私有成员，并且不能被这个派生类的子类所访问。

3. 保护继承(protected)  

保护继承的特点是基类的所有公有成员和保护成员都成为派生类的保护成员，并且只能被它的派生类成员函数或友元访问，基类的私有成员仍然是私有的。

## 细节
**派生类的对象在创建得确保基类的初始化**
在C++中，当派生类继承了基类时，派生类对象的构造函数会调用基类的构造函数来初始化基类成员。如果基类有默认构造函数，那么编译器会自动调用它，**否则需要在派生类的构造函数中手动调用基类构造函数。**

如果基类中有带参数的构造函数，那么需要在派生类构造函数中显示地调用基类的构造函数，并且要在派生类构造函数的成员初始化列表中进行。成员初始化列表需要在派生类构造函数的函数体之前声明，它的语法形式为：基类名(参数列表)。

下面是一个例子，说明基类数据成员初始化在派生类构造函数中的具体实现：
```
class Base {
public:
    int num;
    Base(int n) : num(n) {}
};

class Derived : public Base {
public:
    int val;
    Derived(int n, int m) : Base(n), val(m) {}
};
```
在这个例子中，基类Base有一个带参数的构造函数，派生类Derived也有一个带参数的构造函数。在Derived的构造函数中，首先需要调用基类Base的构造函数Base(n)，然后再初始化派生类的成员val(m)。