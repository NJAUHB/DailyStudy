# 回调函数
## 定义
- **可执行代码**(函数A)作为**参数**(fn)传入**其他的可执行代码**(函数B) 
- 并由其他的可执行代码在T时刻执行这段可执行代码，得到结果P   

生活中的回调函数：  
- 场景一    
有一个房间里没有灯，只有一个 灯座  
你给 灯座 装上了一盏 白炽灯  
到了晚上，你 打开了灯座上的开关  
灯座通了电，点亮了 灯座上的那盏灯  
于是，那盏 白炽灯 发出的 温暖的光 浸满了整个房间  
这里对应了定义描述的五个要素：  
👇  
白炽灯 相当于是 函数 A  
灯座 相当于是 函数 B  
对于灯座来说，灯座上的那盏灯 相当于是 参数 fn  
对于灯座来说，打开灯座上的开关 相当于是 调用的时刻 T  
温暖的光 相当于是 回调结果 P  
- 场景二  
一天，你在房间里开了一个聚会，希望把灯光换成彩色的  
于是，把灯座上的 白炽灯 换成了 彩灯  
当你 打开灯座上的开关时，房间里充满了 彩色的光  
场景二和场景一相比，  
👇
相同的要素是：灯座、灯座上的那盏灯、打开灯座上的开关  
不同的要素是：彩灯、彩色的光  

这里说明了**回调函数的设计初衷** —— 利用 依赖注入 (dependency injection, DI) 实现 控制反转 (Inversion of Control, IoC) 和 依赖倒置 (dependency inversion principle, DIP)，即**将控制权下发给回调函数**：  
灯座 不需要知道灯座上的灯是 白炽灯 还是 彩灯  
灯座 只需要知道 灯座上有一盏灯  
灯座 在你 打开灯座上的开关时，会点亮 灯座上有一盏灯  
这样就可以 换上不同的灯泡，得到不同颜色的灯光。  

在C++中，回调通常（即上面所举例的灯）是通过函数指针，函数对象，或者lambda表达式来实现的。  
简而言之，回调函数就是**允许用户把需要调用的方法(函数A)的指针作为参数(fn)**传递给一个**函数(函数B)**，以便该函数(函数B)在处理相似事件的时候可以灵活的使用不同的方法。
```
int Callback()    // /< 回调函数
{
    // TODO
    return 0;
}
int main()     // /<  主函数
{
    // TODO
    Library(Callback);  // /< 库函数通过函数指针进行回调
    // TODO
    return 0;
}
```
# 函数指针
[飞书笔记](https://li.feishu.cn/docx/RqJ2dCWEDobXthxJYAlcMLOwnce#Zv2idG8Z5oLDWjx3WVicJPKtnSh)
## 深入讨论  
> [参考代码](https://bot-man-jl.github.io/articles/?post=2017/Callback-Explained)
实际上，不管是什么程序设计语言，回调函数都分为 同步 和 异步 两种。 

在同步回调中，回调函数在主函数内部就地执行，主函数会等待回调函数执行完毕后再继续执行。  
- 同步方式：  
通过 参数 传递回调函数  
调用者 立即调用 回调函数（调用时刻 在函数返回前）  
此处的 回调函数 和 调用者 调用栈相同  

在异步回调中，主函数和回调函数在不同的线程中执行，主函数不会等待回调函数执行完毕。  
- 异步方式：
通过 注册（例如 signal 函数）设置回调函数  
调用者 先存储 回调函数，在未来的某个 调用时刻，取出并调用 回调函数  
此处的 回调函数 和 调用者 调用栈不同  