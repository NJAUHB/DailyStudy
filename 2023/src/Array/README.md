# Array数组学习
# 一维数组
## 要点提炼
要点1: 数组可被视为**一段连续的内存**  
要点2: 数组在定义之后长度不可变  
要点3: 数组内的元素可以是任意类型（int，float，bool, struct, class, pointer, enumeration...）  
要点4: 变长数组无法被初始化（if the length is not an inter constant expression,the array will be a variable-length one） 参考代码ArrayUse1.cpp  

```c++
int num_array1[5]={};//这种方式会创建一个大小为5的整数数组，并将所有元素初始化为0。

int num_array1[5];//这种方式会创建一个大小为5的整数数组，但不会初始化元素。也就是说，数组的元素将是未定义的值。在大多数情况下，这些值都是垃圾值。参考代码ArrayUse3.cpp  

int num_array1[5]={0};//这种方式会创建一个大小为5的整数数组，并将所有元素初始化为0，与第一种方式是等价的。

int num_array1[5]={0, 1}; /*这种方式会创建一个大小为5的整数数组，然后依据提供的初始化列表对数组进行初始化。对于这个特定的例子，第一个元素会被初始化为0，第二个元素会被初始化为1，而剩下的元素（索引为2, 3, 4的元素）会被自动初始化为0。
这是因为在C++中，如果一个数组的初始值列表中的元素个数少于数组的长度，那么剩下的元素将会被值初始化，对于基本类型，如int，值初始化就是初始化为0。 如果初始值列表中的元素个数大于数组的长度，则会引发编译错误。*/

int num_array1[] = {0, 1}; //编译器会根据初始化列表中的元素数量自动创建一个适当大小的数组。在这个例子中，会创建一个大小为2的整数数组。第一个元素被初始化为0，第二个元素被初始化为1。
```
## 元素访问  
```c++
int array1[3] = {0};
int array2[3];
array2 = array1;//error: invalid array assignment
array2[0] = array1[0];// ok

```
！！！**No bounds-checking in c++** 数组没有边界检查！！！这也算是c/c++数组的一个优点，因为没有边界检查所以它效率高，一个时钟周期就能够完成读写！！！  
## 一维数组的数组名
主要有两个作用：  
1: 可以统计整个数组在内存中的长度`sizeof(array_name)`  
2: 可以获取**数组在内存中的首地址**  (be like pointer)  **`array_name = &array_name[0]`** 
# 多维数组  
&emsp;  因为内存是一维的，所以多维数组其实也是按照一维的方式去存储的（概念是多维，但是内存中连续存放）！
# 常量数组  
&emsp;  创建一个常量数组，它的值在声明后不能被改变。这可以通过在类型说明符之前添加**const**关键字来实现。  

常量数组经常被作为函数参数，避免误操作数组！！！  
---

# char *与char a[ ], char ** 与 char *a[] 区别
## char* s 与 char a[ ]
char * 与 char a[ ] 的本质区别： 
当定义 `char a[10]` 时，编译器会给数组分配十个单元，每个单元的数据类型为字符。  
而定义 `char* s` 时， 这是个指针变量，只占四个字节，32位，用来保存一个地址。  
```
sizeof(a) = 10 ；

sizeof(s) = ?// 4(32位操作系统)or8(64位操作系统)
```
前面说到 a代表字符串的首地址，而s这个指针也保存字符串的地址（其实首地址），即第一个字符的地址，这个地址单元中的数据是一个字符，
这也与s所指向的char一致:  

因此可以 s = a;

但是不能 a = s;

## char** s 与 char* a[ ]
令： `char* a[] = {"hello", "my", "friend"}`  
`char** s`,char **为二级指针， s保存一级指针 char *的地址，关于二级指针就在这里不详细讨论了，参考代码ArrayUse2.cpp。
