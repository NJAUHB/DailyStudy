&emsp; 在软件系统中，经常有这样一些特殊的类，必须保证他们在系统中只存在一个实例，才能确保它们的逻辑正确性、以及良好的效率。所以得考虑如何绕过常规的构造器（不允许使用者new出一个对象），提供一种机制来保证一个类只有一个实例。  
**定义：** 保证一个类仅有一个实例，并提供一个该实例的全局访问点
# 单例模式分类
&emsp; 单例模式可以分为懒汉式和饿汉式，两者之间的区别在于创建实例的时间不同：   
* 懒汉式：指系统运行中，实例并不存在，只有当需要使用该实例时，才会去创建并使用实例。（这种方式要考虑线程安全）  
* 饿汉式：指系统一运行，就初始化创建实例，当需要时，直接调用即可。（本身就线程安全，没有多线程的问题）  
&emsp; 想重点说明一下：在**C++11标准**以后，局部静态变量的初始化被保证为线程安全，所以我们可以很容易实现一个线程安全的单例类。这也不需要我们自己去造轮子确保线程安全勒！ 如下面示例： 
```
class Foo
{
public:
    static Foo *getInstance()
    {
        static Foo s_instance;
        return &s_instance;
    }
private:
    Foo() {}
};
```

# 单例类特点

.构造函数和析构函数为private类型，目的禁止外部构造和析构  
.拷贝构造和赋值构造函数为private类型，目的是禁止外部拷贝和赋值，确保实例的唯一性  
.类里有个获取实例的静态函数，可以全局访问  

# 知识点 
* 局部静态变量：局部静态变量是在函数或者代码块内部定义的静态变量。它们在程序运行期间只会被初始化一次，而它的生命周期则贯穿整个程序的运行期间。