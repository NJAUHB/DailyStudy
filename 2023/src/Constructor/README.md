# 构造函数
> 构造函数是一种特殊的类成员函数，是当创建一个类的对象时，它被调用来对类的数据成员进行初始化和分配内存。（构造函数的命名必须和类名完全相同）
首先说一下一个C++的空类，编译器会加入哪些默认的成员函数

. 默认构造函数（Default constructor）

. 拷贝构造函数（Copy constructor）

. 拷贝赋值运算符（Copy assignment operator）

. 析构函数（Destructor）

&emsp; 在C++ 11及以后的版本中，还会生成两个额外的构造函数：  

. 移动构造函数（Move constructor）  

. 移动赋值运算符（Move assignment operator）  

**即使程序没定义任何成员，编译器也会插入以上的函数！**

注意：构造函数可以被重载，可以多个，可以带参数；析构函数只有一个，不能被重载，不带参数而默认构造函数没有参数，它什么也不做。当没有重载无参构造函数时，`A a`就是通过默认构造函数来创建一个对象
## 默认构造函数 Default Constructor
默认构造函数是一种特殊的构造函数，当对象被创建但**没有给出任何初始化参数**(即：没有参数或每个参数有初始值)时，该构造函数会被调用。它可以被编程者显式定义，也可以被编译器隐式生成   

默认构造函数的调用场合：  
默认构造函数在默认初始化和值初始化中得到调用。  
* 默认初始化：在不使用初始化器构造变量时执行的初始化。  
* 值初始化：在以空初始化器构造对象时进行的初始化  
说人话：如果构造函数在未指定参数或者提供了一个空初始化器列表，则会调用默认构造函数：
```
vector v1;
vector v2{};
```
&emsp; 如果没有定义任何构造函数，则编译器会提供一个默认构造函数：如果你没有为一个类定义任何构造函数，编译器会隐式为你生成一个默认构造函数。生成的默认构造函数将不进行任何成员初始化。  
## 转换构造函数 Converting constructor
&emsp;作用是将一个其他类型的数据转换成一个类的对象
以下是一些关于转换构造函数的关键点：
* 单参数构造函数（**c++11之前**）：转换构造函数必须是单参数构造函数。换句话说，它的参数数量必须是一个。有时，也可以看到有默认参数的转换构造函数，虽然这些构造函数的参数不止一个，但是其他参数都有默认值，所以仍然可以做到只需要一个参数就可以调用构造函数，这也算是转换构造函数。
* 自动类型转换：编译器可以自动调用转换构造函数，进行必要的类型转换。例如，如果你试图把一个整数赋值给一个类对象，而这个类恰好有一个接受整数的转换构造函数，那么这个构造函数就会被自动调用，把这个整数转换为这个类的一个对象。
* 转换构造函数并不总是好的：虽然在一些情况下转换构造函数很方便，但是在某些情况下，过度使用转换构造函数可能导致一些意料之外的结果。而且，由于转换构造函数能够隐式地进行类型转换，因此它们可能会使得代码难以理解和调试。
```
class MyClass {
    private:
        int x;
    public:
        MyClass(int val) : x(val) {} // 转换构造函数

        int getValue() { return x; }
};

int main() {
    MyClass obj = 20;         // 这个时候会调用调用 MyClass(int val):x(val) {} 。
    std::cout << obj.getValue(); // 打印 "20"
    return 0;
}
```
------------------------------------------------------------**在这里重点说明一下c++11之后的转换构造函数**------------------------------------------------------------  
下例中：  
```
struct foo
{     // Converting constructor yes or no
  foo(int x);              // 1 y
  foo(char* s, int x = 0); // 2 y
  foo(float f, int x);     // 3 y(since c++11)
  explicit foo(char x);    // 4 n
};
```
Constructors 1 and 2 are both converting constructors in C++03 and C++11. Constructor 3, which must take two arguments, **is only a converting constructor in C++11**. The last, constructor 4, is not a converting constructor because it is [explicit](https://www.cnblogs.com/rednodel/p/9299251.html).  

The following example is also a converting constructor in c++11
```
class A{
    public:
        A(int a, int b){}
}
```
`A a4 = {4, 5}; // OK, Convert Constructor: copy-list-initialization selects A::A(int, int)`
## 拷贝构造函数 Copy constructors
>拷贝构造函数是C++独有的，它是一种特殊的构造函数，用基于同一类的一个对象构造和初始化另一个对象。当没有重载拷贝构造函数时，通过默认拷贝构造函数来创建一个对象  

1、使用场景1：When an object of the class is passed (to a function) by value as an argument. 用对象1 初始化 对象2  
```
A a;

A b(a);

A b=a; 都是拷贝构造函数来创建对象b

强调：这里b对象是不存在的，是用a 对象来构造和初始化b的！！!如果b是存在的，那么就是赋值函数了  

参考代码Constructor1.cpp
```

2、使用场景2：When an object of the class is passed (to a function) by value as an argument. 这个对象以值传递的方式传给全局函数形参  
```
void func(AA a1)
{
    cout<<a1.getA()<<endl;
}//调用a1的析构函数

void main()
{
    AA a;//调用一次构造函数
    func(a);//传递实参a，用a初始化形参a1，相当于AA a1 = a;
}//调用a的析构函数

```

3、使用场景3：When an object of the class is returned by value. 在全局函数中，把对象作为返回值  
```
AA func()
{
    AA temp(100);//调用一次构造函数，创建temp对象
    return temp;/*调用一次拷贝构造函数，用temp创建一个匿名对象，当匿名对象接过temp时，析构temp*/
}
void main()
{
    AA a1 = func();/*这里是初始化a1，直接接过func返回的匿名对象，不再调用构造函数*/
    AA a2;
    a2 = func();//这里是给a2赋值，要调用构造函数
```
### 拷贝构造函数重载声明
拷贝构造函数重载声明如下：  
`A (const A&other)`  
```
class A {
  int m_i;
  A(const A& other):m_i(other.m_i) {
    Cout<<”拷贝构造函数”<<endl;
  }
}
```
参考代码Constructor2.cpp 
### 默认拷贝构造函数
编译器生成的默认拷贝构造函数只会做**浅拷贝**，就是对数据成员执行逐位复制。如果对象的数据成员中包含指针，那么浅拷贝会造成严重的问题。所以在包含指针的类中，**我们通常需要自定义拷贝构造函数，来执行深拷贝**。

下面说说深拷贝与浅拷贝： 
>浅拷贝：如果复制的对象中引用了一个外部内容（例如分配在堆上的数据），那么在复制这个对象的时候，让新旧两个对象指向同一个外部内容，就是浅拷贝。（指针虽然复制了，但所指向的空间内容并没有复制，而是由两个对象共用，两个对象不独立，删除空间存在），改变一个对象的值，另一个也会改变

>深拷贝：如果在复制这个对象的时候为新对象制作了外部对象的独立复制，就是深拷贝。改变一个对象的值，另一个不会变
## 赋值函数(operator = )
当 一个类的对象 向 该类的另一个对象 赋值时，就会用到该类的赋值函数。当没有重载赋值函数（赋值运算符）时，通过默认赋值函数来进行赋值操作。
```
A a;

A b;

b=a;

强调：这里a,b对象是已经存在的，是用a 对象来赋值给b的！！
```
### 赋值运算的重载声明如下：
`A& operator = (const A& other)`  
### 赋值函数与拷贝构造函数的区别
* 拷贝构造函数是一个对象初始化一块内存区域，这块内存就是新对象的内存区，而赋值函数是对于一个已经被初始化的对象来进行赋值操作。  
```
class  A;
A a;
A b=a;   //调用拷贝构造函数（b不存在）
A c(a) ;   //调用拷贝构造函数
 
/****/
 
class  A;
A a;
A b;   
b = a ;   //调用赋值函数(b存在)
```
* 一般来说在数据成员包含指针对象的时候，需要考虑两种不同的处理需求：一种是复制指针对象，另一种是引用指针对象。拷贝构造函数大多数情况下是复制，而赋值函数是引用对象。  

* 实现不一样。拷贝构造函数首先是一个构造函数，它调用时候是通过参数的对象初始化产生一个对象。赋值函数则是把一个新的对象赋值给一个原有的对象，所以如果原来的对象中有内存分配要先把内存释放掉，而且还要检察一下两个对象是不是同一个对象，如果是，不做任何操作，直接返回。  

**！！！！！！如果不想写拷贝构造函数和赋值函数，又不允许别人使用编译器生成的缺省函数，最简单的办法是将拷贝构造函数和赋值函数声明为私有函数，不用编写代码。！！！！！！**  
eg：  
```
class A {
  private:
  A(const A& a); //私有拷贝构造函数
  A& operate=(const A& a); //私有赋值函数
}
```  

**！！！！！！所以如果类定义中有指针或引用变量或对象，为了避免潜在错误，最好重载拷贝构造函数和赋值函数。！！！！！！**  
&emsp;参考代码Constructor3.cpp  
&emsp;如参考代码所示，我们为 demo 类自定义了一个拷贝构造函数。该函数在拷贝 d.num 指针成员时，必须采用深拷贝的方式，即拷贝该指针成员本身的同时，还要拷贝指针指向的内存资源。否则一旦多个对象中的指针成员指向同一块堆空间，这些对象析构时就会对该空间释放多次，这是不允许的。  
## 移动构造函数  
>所谓移动语义，指的就是以移动而非深拷贝的方式初始化含有指针成员的类对象。简单的理解，移动语义指的就是将其他对象（通常是临时对象）拥有的内存资源“移为已用”。  [移动构造函数](https://c.biancheng.net/view/7847.html)
参考代码Constructor4.cpp    

